// js/core/widget-data-manager.js
// Manages data flow between main app and widget iframes
// Handles widget registration, postMessage communication, and data updates

import { createLogger } from '../utils/logger.js';
import { getCalendarService } from '../data/services/calendar-service.js';
import { calendarCache } from '../utils/calendar-cache.js';
import { CALENDAR_CACHE_REFRESH_THRESHOLD_MS } from '../../config.js';
import AppComms from './app-comms.js';

const logger = createLogger('WidgetDataManager');

export class WidgetDataManager {
    constructor() {
        this.widgets = new Map(); // widgetId → iframe element
        this.refreshIntervals = new Map(); // widgetId → interval ID
        this.widgetStates = new Map(); // widgetId → state object

        // Cache for calendar data to avoid duplicate fetches
        this.calendarDataCache = null;
        this.calendarDataPromise = null; // Track in-flight requests

        logger.debug('WidgetDataManager constructed');
    }

    /**
     * Initialize the widget data manager
     */
    async initialize() {
        logger.debug('WidgetDataManager initializing');

        // Initialize calendar cache
        try {
            await calendarCache.initialize();
            logger.debug('Calendar cache initialized');
        } catch (error) {
            logger.warn('Failed to initialize calendar cache, will fallback to fetch-only', error);
        }

        // Set up global message listener for all widgets
        window.addEventListener('message', (event) => {
            this.handleWidgetMessage(event.data);
        });

        // Set up listener for automatic photo refresh
        window.addEventListener('photo-data-updated', (event) => {
            const photoData = event.detail.photos;
            if (photoData && this.widgets.has('photos')) {
                logger.debug('Photo auto-refresh detected, updating photo widget');
                this.sendToWidget('photos', 'data', {
                    dataType: 'photos',
                    payload: {
                        urls: photoData.urls || [],
                        folder: photoData.folder || null
                    }
                });
            }
        });

        // Set up voice event listeners (forward to voice widget)
        this._setupVoiceEventListeners();

        // Set up AI response listeners (forward to AI response widget)
        this._setupAIResponseListeners();

        logger.verbose('WidgetDataManager initialized');
    }

    /**
     * Setup voice event listeners to forward events to voice widget
     * @private
     */
    _setupVoiceEventListeners() {
        const voiceEvents = [
            'VOICE_LISTENING_STARTED',
            'VOICE_LISTENING_STOPPED',
            'VOICE_PARTIAL_RESULT',
            'VOICE_TRANSCRIPT_RECEIVED',
            'VOICE_ERROR',
            'VOICE_COMMAND_EXECUTED',
            'VOICE_WAKE_WORD_DETECTED'
        ];

        voiceEvents.forEach(eventType => {
            AppComms.on(eventType, (data) => {
                logger.debug('Voice event received, checking if voice widget exists', {
                    eventType,
                    hasVoiceWidget: this.widgets.has('voice'),
                    allWidgets: Array.from(this.widgets.keys())
                });

                if (this.widgets.has('voice')) {
                    logger.debug('Sending voice event to widget', { eventType, data });

                    // Send directly to iframe with proper structure
                    const iframe = this.widgets.get('voice');
                    if (iframe && iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'data',
                            action: 'voice-event',
                            payload: {
                                eventType,
                                data
                            }
                        }, '*');
                    }
                } else {
                    logger.warn('Voice widget not registered, cannot send event', { eventType });
                }
            });
        });

        logger.debug('Voice event listeners registered');
    }

    /**
     * Setup AI response listeners to forward responses to AI response widget
     * @private
     */
    _setupAIResponseListeners() {
        // Listen for AI responses generated by VoiceCommandRouter
        AppComms.on('AI_RESPONSE_GENERATED', (response) => {
            logger.debug('AI response generated, checking if ai-response widget exists', {
                hasAIResponseWidget: this.widgets.has('ai-response'),
                allWidgets: Array.from(this.widgets.keys())
            });

            if (this.widgets.has('ai-response')) {
                logger.debug('Sending AI response to widget', { response });

                // Use the same timestamp as the user message for consistency
                const responseWithTimestamp = {
                    ...response,
                    timestamp: this._lastUserMessageTimestamp || response.timestamp
                };

                this.sendToWidget('ai-response', 'data', {
                    action: 'add-message',
                    payload: responseWithTimestamp
                });
            } else {
                logger.warn('AI response widget not registered, cannot send response');
            }
        });

        logger.debug('AI response listeners registered');
    }

    /**
     * Handle voice actions from voice widget (e.g., start/stop listening)
     * @param {string} action - Voice action to perform
     */
    async handleVoiceAction(action) {
        logger.debug('Voice action received from widget', { action });

        // Get VoiceService from window (initialized in core-initializer)
        const voiceService = window.voiceService;

        if (!voiceService) {
            logger.error('VoiceService not available');
            return;
        }

        switch (action) {
            case 'start-listening':
                voiceService.startListening();
                break;

            case 'stop-listening':
                voiceService.stopListening();
                break;

            case 'cancel-listening':
                voiceService.cancelListening();
                break;

            default:
                logger.warn('Unknown voice action', { action });
                break;
        }
    }

    /**
     * Handle user messages from voice widget (text or voice input)
     * @param {object} payload - Message payload with content, source, etc.
     */
    async handleUserMessage(payload) {
        const { messageId, source, content, timestamp, metadata } = payload;

        logger.info('User message received', {
            messageId,
            source,
            content,
            platform: metadata?.platform
        });

        // Send user message to AI Response widget (if it exists)
        if (this.widgets.has('ai-response')) {
            this.sendToWidget('ai-response', 'data', {
                action: 'add-message',
                payload: {
                    sender: 'user',
                    content,
                    timestamp,
                    messageId,
                    metadata: { source }
                }
            });
        }

        // Get VoiceCommandRouter from window (initialized in core-initializer)
        const voiceCommandRouter = window.voiceCommandRouter;

        if (!voiceCommandRouter) {
            logger.error('VoiceCommandRouter not available');
            return;
        }

        // Store the original timestamp for the response
        this._lastUserMessageTimestamp = timestamp;

        // Process the command through the router
        // The router will determine if it's a simple command or needs AI
        voiceCommandRouter.processCommand(content);

        // Emit event for other listeners
        AppComms.emit('USER_MESSAGE_SENT', {
            messageId,
            source,
            content,
            timestamp
        });
    }

    /**
     * Register a widget iframe
     * @param {string} widgetId - Widget identifier
     * @param {HTMLIFrameElement} iframe - Widget iframe element
     */
    registerWidget(widgetId, iframe) {
        if (!widgetId || !iframe) {
            logger.error('Invalid widget registration', { widgetId, iframe });
            return;
        }

        this.widgets.set(widgetId, iframe);
        this.widgetStates.set(widgetId, {
            ready: false,
            hasMenu: false,
            menuItems: []
        });

        logger.verbose('Widget registered', {
            widgetId,
            iframeId: iframe.id,
            totalRegistered: this.widgets.size,
            allWidgets: Array.from(this.widgets.keys())
        });
    }

    /**
     * Unregister a widget
     * @param {string} widgetId - Widget identifier
     */
    unregisterWidget(widgetId) {
        // Stop auto-refresh
        this.stopAutoRefresh(widgetId);

        // Remove from maps
        this.widgets.delete(widgetId);
        this.widgetStates.delete(widgetId);

        logger.debug('Widget unregistered', { widgetId });
    }

    /**
     * Handle messages from widgets
     * @param {object} message - Message from widget
     */
    async handleWidgetMessage(message) {
        if (!message || !message.type) return;

        // Handle voice actions from voice widget
        if (message.type === 'voice-action' && message.action) {
            await this.handleVoiceAction(message.action);
            return;
        }

        // Handle user messages (text or voice) from voice widget
        if (message.type === 'user-message' && message.payload) {
            await this.handleUserMessage(message.payload);
            return;
        }

        // Handle widget-config message (focus menu registration)
        if (message.type === 'widget-config' && message.widget) {
            await this.handleWidgetConfig(message);
            return;
        }

        // Handle standard widget-ready format: {type: 'widget-ready', widgetId: 'photos'}
        if (message.type === 'widget-ready' && message.widgetId) {
            logger.debug('Widget ready (standard format)', { widgetId: message.widgetId });
            await this.handleWidgetReady(message.widgetId, { hasMenu: message.hasMenu });
            return;
        }

        // Handle legacy event wrapper format: {type: 'event', eventType: 'widget-ready'}
        if (message.type === 'event' && message.widgetId) {
            const { widgetId, payload } = message;
            const { eventType, data } = payload || {};

            logger.debug('Widget event received (legacy format)', { widgetId, eventType });

            switch (eventType) {
                case 'widget-ready':
                    await this.handleWidgetReady(widgetId, data);
                    break;

                case 'return-to-menu':
                    this.handleReturnToMenu(widgetId);
                    break;

                case 'settings-requested':
                    this.handleSettingsRequested(widgetId);
                    break;

                default:
                    logger.debug('Unhandled widget event', { widgetId, eventType });
                    break;
            }
        }
    }

    /**
     * Handle widget config message (focus menu registration)
     * @param {object} message - Message from widget
     */
    async handleWidgetConfig(message) {
        const { widget: widgetId, focusMenu } = message;

        logger.debug('Widget config received', { widgetId, hasFocusMenu: !!focusMenu });

        // Register focus menu if provided
        if (focusMenu) {
            try {
                // Dynamically import FocusMenuStateManager to avoid circular dependencies
                const { default: FocusMenuStateManager } = await import(
                    '../modules/Dashboard/components/focus-menu/state-manager.js'
                );

                // Register the widget's menu configuration
                FocusMenuStateManager.registerWidgetMenu(widgetId, focusMenu);

                logger.info('Widget menu registered', {
                    widgetId,
                    enabled: focusMenu.enabled,
                    itemCount: focusMenu.items?.length || 0
                });
            } catch (error) {
                logger.error('Failed to register widget menu', { widgetId, error });
            }
        }
    }

    /**
     * Handle widget ready event
     * @param {string} widgetId - Widget identifier
     * @param {object} data - Widget metadata
     */
    async handleWidgetReady(widgetId, data = {}) {
        logger.verbose('Widget ready', { widgetId, data });

        // Update widget state
        const state = this.widgetStates.get(widgetId);
        if (state) {
            state.ready = true;
            state.hasMenu = data.hasMenu || false;
            state.menuItems = data.menuItems || [];
        }

        // Load initial data for the widget
        await this.loadWidgetData(widgetId);
    }

    /**
     * Load data for a specific widget
     * @param {string} widgetId - Widget identifier
     */
    async loadWidgetData(widgetId) {
        logger.debug('Loading widget data', { widgetId });

        try {
            // Determine widget type from ID (supports clock-1, clock-2, camera-1, etc.)
            let widgetType = widgetId;

            // Extract base type from numbered IDs (e.g., 'clock-1' → 'clock')
            if (widgetId.includes('-')) {
                widgetType = widgetId.split('-')[0];
            }

            // Handle widget types
            if (widgetType === 'clock') {
                await this.loadClockData(widgetId); // Pass the specific widget ID (e.g., 'clock-1')
            } else if (widgetId === 'main' || widgetId === 'agenda') {
                // Calendar widgets
                const calendarData = await this.loadCalendarData();

                // Send data to widgets (cache or fresh)
                // Only send if background refresh is NOT in progress
                // (if it is, the background refresh will send the fresh data)
                if (calendarData && !this._backgroundRefreshInProgress) {
                    const payload = {
                        dataType: 'calendar',
                        calendars: calendarData.calendars || [],
                        events: calendarData.events || [],
                        lastUpdated: Date.now()
                    };

                    this.sendToWidget('main', 'data', payload);
                    this.sendToWidget('agenda', 'data', payload);

                    logger.debug('Sent calendar data to widgets', {
                        widgetId,
                        calendars: payload.calendars.length,
                        events: payload.events.length
                    });
                } else if (this._backgroundRefreshInProgress) {
                    logger.debug('Background refresh in progress, will send fresh data when ready', { widgetId });
                }
            } else if (widgetType === 'photos') {
                await this.loadPhotosData(widgetId); // Pass the specific widget ID (e.g., 'photos-1')
            } else if (widgetType === 'header') {
                await this.loadHeaderData();
            } else if (widgetType === 'camera') {
                // Future: load camera data
                logger.debug('Camera widget detected (no data loader yet)', { widgetId });
            } else {
                logger.debug('No data loader for widget type', { widgetId, widgetType });
            }

        } catch (error) {
            logger.error('Failed to load widget data', {
                widgetId,
                error: error.message
            });
        }
    }

    /**
     * Load calendar data and send to calendar widget
     * Loads events from all active calendars configured by the user
     * Uses persistent cache for fast loading
     */
    async loadCalendarData(options = {}) {
        try {
            // Check if we're in bypass mode (no auth/database)
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('bypass-auth')) {
                logger.debug('Bypass mode active - skipping calendar data load');
                return { events: [], calendars: [], lastUpdated: null };
            }

            // If there's already a fetch in progress, wait for it instead of starting a new one
            if (this.calendarDataPromise) {
                logger.debug('Calendar data fetch already in progress, waiting...');
                return await this.calendarDataPromise;
            }

            // If we have in-memory cached data, return it (fastest path)
            if (this.calendarDataCache && !options.forceRefresh) {
                logger.debug('Returning in-memory cached calendar data');
                return this.calendarDataCache;
            }

            // Try to load from persistent cache (fast path - survives page reloads)
            // This serves stale data by default, so users never see loading after first fetch
            if (!options.forceRefresh) {
                try {
                    const cachedData = await calendarCache.get('calendar-data', { allowStale: true });
                    if (cachedData) {
                        // Get metadata to check if we need to refresh
                        const metadata = await calendarCache.getMetadata('calendar-data');

                        logger.success('Loaded calendar data from persistent cache', {
                            events: cachedData.events?.length,
                            calendars: cachedData.calendars?.length,
                            age: metadata ? `${Math.round(metadata.age / 1000)}s` : 'unknown',
                            isStale: metadata ? metadata.isExpired : false
                        });

                        this.calendarDataCache = cachedData;

                        // Start background refresh if cache is stale (expired) OR older than threshold
                        // This ensures users never see "loading" - we serve cached data and refresh behind the scenes
                        if (metadata && (metadata.isExpired || metadata.age > CALENDAR_CACHE_REFRESH_THRESHOLD_MS)) {
                            logger.debug('Cache needs refresh, updating in background', {
                                age: `${Math.round(metadata.age / 1000)}s`,
                                isExpired: metadata.isExpired,
                                threshold: `${CALENDAR_CACHE_REFRESH_THRESHOLD_MS / 1000}s`
                            });
                            this._refreshCalendarDataInBackground();
                        }

                        return cachedData;
                    }
                } catch (cacheError) {
                    logger.warn('Failed to load from cache, will fetch fresh', cacheError);
                }
            }

            logger.debug('Loading calendar data from API');

            // Create a promise for this fetch so other simultaneous calls can wait for it
            this.calendarDataPromise = this._fetchCalendarData();

            try {
                const data = await this.calendarDataPromise;
                this.calendarDataCache = data;

                // Store in persistent cache for next time
                try {
                    await calendarCache.set('calendar-data', data);
                } catch (cacheError) {
                    logger.warn('Failed to cache calendar data', cacheError);
                }

                return data;
            } finally {
                // Clear the in-flight promise
                this.calendarDataPromise = null;
            }
        } catch (error) {
            this.calendarDataPromise = null;
            logger.error('Failed to load calendar data', error);
            throw error;
        }
    }

    /**
     * Refresh calendar data in background without blocking
     * @private
     */
    _refreshCalendarDataInBackground() {
        // Don't start multiple background refreshes
        if (this._backgroundRefreshInProgress) {
            return;
        }

        this._backgroundRefreshInProgress = true;

        this._fetchCalendarData()
            .then(async (data) => {
                this.calendarDataCache = data;
                await calendarCache.set('calendar-data', data);

                // Send updated data to widgets
                const payload = {
                    dataType: 'calendar',
                    calendars: data.calendars || [],
                    events: data.events || [],
                    lastUpdated: Date.now()
                };

                this.sendToWidget('main', 'data', payload);
                this.sendToWidget('agenda', 'data', payload);

                logger.success('Background refresh completed and sent to widgets', {
                    calendars: payload.calendars.length,
                    events: payload.events.length
                });
            })
            .catch((error) => {
                logger.warn('Background refresh failed', error);
            })
            .finally(() => {
                this._backgroundRefreshInProgress = false;
            });
    }

    /**
     * Internal method to fetch calendar data (called by loadCalendarData)
     * Delegates to calendar-service for all fetching logic
     * @private
     */
    async _fetchCalendarData() {
        try {
            // Get calendar service
            const calendarService = getCalendarService();

            logger.debug('Fetching calendar data from service');

            // Delegate to calendar service (handles all fetching, grouping, metadata, etc.)
            const data = await calendarService.loadData({ forceRefresh: false });

            logger.success('Calendar data loaded', {
                calendars: data.calendars.length,
                events: data.events.length
            });

            return data;

        } catch (error) {
            logger.error('Failed to load calendar data', {
                error: error.message
            });

            // Return empty data on error
            return {
                calendars: [],
                events: []
            };
        }
    }

    /**
     * Load photos data and send to photos widget
     */
    /**
     * Load photos data
     * @param {string} widgetId - Widget identifier (e.g., 'photos', 'photos-1')
     */
    async loadPhotosData(widgetId = 'photos') {
        try {
            // Check if we're in bypass mode (no auth/database)
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('bypass-auth')) {
                logger.debug('Bypass mode active - skipping photos data load');
                this.sendToWidget(widgetId, 'data', {
                    dataType: 'photos',
                    payload: { urls: [], folder: null }
                });
                return;
            }

            logger.debug('Loading photos data', { widgetId });

            // Get photo data service
            const photoDataService = window.photoDataService;
            if (!photoDataService || !photoDataService.isReady()) {
                logger.warn('PhotoService not available or not ready');
                this.sendToWidget(widgetId, 'data', {
                    dataType: 'photos',
                    payload: { urls: [], folder: null }
                });
                return;
            }

            // Load photos from service
            const result = await photoDataService.loadPhotos(null, true); // folder=null, shuffle=true

            logger.success('Photos data loaded', { widgetId, count: result?.urls?.length || 0 });

            // Send photos to widget
            this.sendToWidget(widgetId, 'data', {
                dataType: 'photos',
                payload: {
                    urls: result?.urls || [],
                    folder: result?.folder || null
                }
            });

        } catch (error) {
            logger.error('Failed to load photos data', {
                widgetId,
                error: error.message
            });

            // Send empty array on error
            this.sendToWidget(widgetId, 'data', {
                dataType: 'photos',
                payload: { urls: [], folder: null }
            });
        }
    }

    /**
     * Load clock data (fetch and send weather data)
     * @param {string} widgetId - Widget identifier (e.g., 'clock', 'clock-1', 'clock-2')
     */
    async loadClockData(widgetId = 'clock') {
        try {
            logger.debug('Loading clock data (weather)', { widgetId });

            // Get zip code from settings
            const settingsStore = window.settingsStore;
            if (!settingsStore) {
                logger.warn('SettingsStore not available for clock data');
                return;
            }

            const zipCode = settingsStore.get('family.zipCode');

            if (!zipCode) {
                logger.warn('No zip code in settings, clock weather will not display');
                return;
            }

            // Get weather service
            const weatherService = window.weatherService;
            if (!weatherService || !weatherService.isReady()) {
                logger.warn('WeatherService not available or not ready');
                // Send location-update as fallback (clock widget can fetch weather itself)
                this.sendToWidget(widgetId, 'location-update', {
                    zipCode: zipCode
                });
                return;
            }

            // Fetch weather data
            logger.debug('Fetching weather for clock widget', { widgetId, zipCode });
            const weatherData = await weatherService.getWeatherForZipCode(zipCode);

            logger.debug('Sending weather data to clock widget', {
                widgetId,
                zipCode,
                temperature: weatherData.temperature,
                weatherCode: weatherData.weatherCode
            });

            // Send weather data to clock widget
            this.sendToWidget(widgetId, 'weather-data', {
                zipCode: zipCode,
                temperature: weatherData.temperature,
                weatherCode: weatherData.weatherCode,
                icon: weatherData.icon,
                timestamp: weatherData.timestamp
            });

            logger.success('Clock weather data sent', {
                widgetId,
                zipCode,
                temperature: weatherData.temperature
            });

        } catch (error) {
            logger.error('Failed to load clock data', {
                widgetId,
                error: error.message
            });
        }
    }

    /**
     * Load header data (placeholder)
     */
    async loadHeaderData() {
        logger.debug('Header data loading not implemented yet');
        // TODO: Implement when header widget is built
    }

    /**
     * Clear calendar data cache (call when calendar settings change)
     */
    clearCalendarCache() {
        logger.debug('Clearing calendar data cache');
        this.calendarDataCache = null;
        this.calendarDataPromise = null;
    }

    /**
     * Send message to a specific widget
     * @param {string} widgetId - Widget identifier
     * @param {string} messageType - Message type (data, command, config)
     * @param {object} payload - Message payload
     */
    sendToWidget(widgetId, messageType, payload) {
        const iframe = this.widgets.get(widgetId);

        if (!iframe || !iframe.contentWindow) {
            logger.warn('Cannot send to widget (not found or not ready)', {
                widgetId,
                hasIframe: !!iframe,
                hasContentWindow: !!iframe?.contentWindow,
                registeredWidgets: Array.from(this.widgets.keys())
            });
            return;
        }

        const message = {
            type: messageType,
            widgetId,
            payload
        };

        iframe.contentWindow.postMessage(message, '*');

        logger.debug('Message sent to widget', {
            widgetId,
            messageType,
            payloadKeys: Object.keys(payload || {})
        });
    }

    /**
     * Broadcast message to all widgets
     * @param {string} messageType - Message type
     * @param {object} payload - Message payload
     */
    broadcastToWidgets(messageType, payload) {
        logger.debug('Broadcasting to all widgets', {
            messageType,
            widgetCount: this.widgets.size
        });

        this.widgets.forEach((iframe, widgetId) => {
            this.sendToWidget(widgetId, messageType, payload);
        });
    }

    /**
     * Start auto-refresh for a widget
     * @param {string} widgetId - Widget identifier
     * @param {number} intervalMs - Refresh interval in milliseconds
     */
    startAutoRefresh(widgetId, intervalMs = 300000) { // 5 minutes default
        // Stop existing interval if any
        this.stopAutoRefresh(widgetId);

        logger.debug('Starting auto-refresh', { widgetId, intervalMs });

        const interval = setInterval(() => {
            logger.debug('Auto-refresh triggered', { widgetId });
            this.loadWidgetData(widgetId);
        }, intervalMs);

        this.refreshIntervals.set(widgetId, interval);
    }

    /**
     * Stop auto-refresh for a widget
     * @param {string} widgetId - Widget identifier
     */
    stopAutoRefresh(widgetId) {
        const interval = this.refreshIntervals.get(widgetId);

        if (interval) {
            clearInterval(interval);
            this.refreshIntervals.delete(widgetId);
            logger.debug('Auto-refresh stopped', { widgetId });
        }
    }

    /**
     * Handle return-to-menu event from widget
     * @param {string} widgetId - Widget identifier
     */
    handleReturnToMenu(widgetId) {
        logger.debug('Widget requesting return to menu', { widgetId });

        // TODO: Emit event for Dashboard to handle
        // For now, just log
    }

    /**
     * Handle settings-requested event from widget
     * @param {string} widgetId - Widget identifier
     */
    handleSettingsRequested(widgetId) {
        logger.debug('Widget requesting settings', { widgetId });

        // TODO: Open Settings module
        // For now, just log
    }

    /**
     * Get widget state
     * @param {string} widgetId - Widget identifier
     * @returns {object} Widget state
     */
    getWidgetState(widgetId) {
        return this.widgetStates.get(widgetId) || null;
    }

    /**
     * Check if widget is ready
     * @param {string} widgetId - Widget identifier
     * @returns {boolean}
     */
    isWidgetReady(widgetId) {
        const state = this.widgetStates.get(widgetId);
        return state ? state.ready : false;
    }

    /**
     * Force refresh calendar data (bypass cache)
     * Useful for manual refresh or when calendar settings change
     * @returns {Promise<object>} Fresh calendar data
     */
    async refreshCalendarData() {
        logger.info('Force refreshing calendar data');

        // Clear in-memory cache
        this.calendarDataCache = null;

        // Clear persistent cache
        try {
            await calendarCache.clear('calendar-data');
        } catch (error) {
            logger.warn('Failed to clear calendar cache', error);
        }

        // Load fresh data (will automatically cache it)
        const data = await this.loadCalendarData({ forceRefresh: true });

        // Send to widgets
        if (data) {
            const payload = {
                dataType: 'calendar',
                calendars: data.calendars || [],
                events: data.events || [],
                lastUpdated: Date.now()
            };

            this.sendToWidget('main', 'data', payload);
            this.sendToWidget('agenda', 'data', payload);

            logger.debug('Sent refreshed calendar data to widgets', {
                calendars: payload.calendars.length,
                events: payload.events.length
            });
        }

        return data;
    }

    /**
     * Get calendar cache metadata
     * @returns {Promise<object|null>} Cache metadata or null if not cached
     */
    async getCalendarCacheMetadata() {
        try {
            return await calendarCache.getMetadata('calendar-data');
        } catch (error) {
            logger.warn('Failed to get cache metadata', error);
            return null;
        }
    }

    /**
     * Clear all calendar cache
     * Useful for troubleshooting or logout
     * @returns {Promise<void>}
     */
    async clearCalendarCache() {
        logger.info('Clearing all calendar cache');

        // Clear in-memory cache
        this.calendarDataCache = null;

        // Clear persistent cache
        try {
            await calendarCache.clearAll();
            logger.success('Calendar cache cleared');
        } catch (error) {
            logger.error('Failed to clear calendar cache', error);
            throw error;
        }
    }

    /**
     * Debug: Get all registered widgets
     * @returns {Array} List of registered widget info
     */
    getRegisteredWidgets() {
        const widgets = [];
        this.widgets.forEach((iframe, widgetId) => {
            const state = this.widgetStates.get(widgetId);
            widgets.push({
                widgetId,
                iframeId: iframe.id,
                ready: state?.ready || false,
                hasContentWindow: !!iframe.contentWindow
            });
        });
        return widgets;
    }

    /**
     * Destroy the widget data manager
     */
    destroy() {
        logger.info('WidgetDataManager destroying');

        // Stop all auto-refresh intervals
        this.refreshIntervals.forEach(interval => clearInterval(interval));
        this.refreshIntervals.clear();

        // Clear widget references
        this.widgets.clear();
        this.widgetStates.clear();

        logger.info('WidgetDataManager destroyed');
    }
}

// Export singleton
let widgetDataManagerInstance = null;

export function initializeWidgetDataManager() {
    if (!widgetDataManagerInstance) {
        widgetDataManagerInstance = new WidgetDataManager();
        widgetDataManagerInstance.initialize();
        logger.verbose('WidgetDataManager singleton initialized');
    }
    return widgetDataManagerInstance;
}

export function getWidgetDataManager() {
    if (!widgetDataManagerInstance) {
        throw new Error('WidgetDataManager not initialized. Call initializeWidgetDataManager() first.');
    }
    return widgetDataManagerInstance;
}
